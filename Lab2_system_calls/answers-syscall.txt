①　通过backtrace输入来看，哪个函数调用了syscall？
答：通过backtrace的输出可以看出kernel/trap.c第67行的usertrap函数调用了syscall。

②　p->trapframe->a7的值是什么，这个值代表什么？
答：根据中*p内容，查询user/initcode.S发现a7代表SYS_exec，故p->trapframe->a7值为7，代表程序执行。

③　CPU之前处于什么模式？
答：查询得$sstatus = 0x22，代表特权级别的SPP字段在第8位，根据sstatus计算得SPP=0，表示 User Mode，故CPU之前应处于用户模式。

④　写下内核中引起崩溃的汇编指令。哪个寄存器对应于变量num？
答：引起崩溃的内核指令为lw a3,0(zero) # 0 <_entry-0x80000000>，对应num的寄存器为0x00002683

⑤　为什么内核会崩溃？地址0是否映射到内核地址空间中？上述scause中的值是否证实了这一点？
答：内核崩溃的原因是因为num需要赋值地址0中的内容，而地址0尚未映射到内核地址空间中，导致num赋值错误引起崩溃。
Scause值为0x000d，查表为Load page fault，即页面加载错误，在该崩溃情况中表示找不到地址0所对应的地址空间，可以证实上面的观点。

⑥　内核死机时运行的二进制文件的名称是什么？它的进程id（pid）是什么？
答：根据使用p p->name和p p->pid查看到的内容，发现内核死机时运行的二进制文件的名称为“initcode\000\000\000\000\000\000\000”，该文件的pid为1。
