1）问题1：哪些寄存器包含函数的参数？例如，在main对printf的调用中，哪个寄存器包含13？
答：执行load指令的寄存器，如a0,a1,a2中包含函数的参数，如根据指令0x24，13包含在a2寄存器中。
2）问题2：main的汇编代码中函数f的调用在哪里？g的调用在哪里？
答：main函数中的printf中调用了f函数，但由于编译器的内联函数，编译时会直接得出结果12，故f在汇编语言中未进行调用；f函数在返回值的过程中调用了g函数，即将x加3后返回。
3）问题3：函数printf位于哪个地址？
答：在call.asm中找到printf函数位置,查找到printf地址为0x64a
4）问题4：在main中打印f的jalr之后，寄存器ra中值是多少？
根据jalr指令的返回值，PC+4赋值给ra，PC跳转到printf函数位置，当前PC=0x34，故ra值为0x38。
5）问题5：运行以下代码
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);
输出是什么？输出取决于RISC-V是小字节序的事实。如果RISC-V改为大端序，你会将i设置为何值以产生相同的输出？需要将57616更改为其他值吗？
答：57616以16进制0xe110输出，故输出为e110；
由于RISC为小端序，故i应通过从右向左两位的方式读取，依次读出为0x72,0x6c,0x64，查ascii码转化为字符串rld，故输出为rld。
故最终输出为He110 World。
若改为大端序，i应改为0x00726c64来保持输出不变。
57616转化为十六进制的过程不受大小端序影响，故不需要更改。
6）问题6：在下面的代码中，在“y=”之后将打印什么（注意：非特定值）？为什么会发生这种情况？
printf("x=%d y=%d", 3);
答：观察编译语言得出：printf通过寄存器a1、a2给两个%d位置赋值再进行输出，若缺少参数，程序会跳过为a2赋值的阶段，因此“y=”之后会输出先前a2中存储的值，若从未为a2赋值，则会输出一个随机值。
